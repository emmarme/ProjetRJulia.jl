---
title: "Rapport de Projet R et Julia"
author: "Emma Roume Jade Bordet"
date: "12/12/2024"
format: html
pdf: default
word: default
---

## Introduction 

Dans le cadre de notre Master 1 en Statistique et Science des Donn√©es, nous avons r√©alis√© un projet dans le cadre des UE Logiciels Sp√©cialis√©s (parties sur R et Julia) et l'UE Outils de pr√©sentation et de recherche reproductible. Ce projet avait pour principal objectif de consolider et d√©velopper nos comp√©tences en programmation avec R mais aussi de d√©couvrir le logiciel Julia. Il fallait faire en deux modes, en mode utilisateur : Environnement de travail ; Notion de package (installation, utilisation); Introduction des natures et structures R de base; Extraction de donn√©es avec application sur donn√©es r√©elles. Mais aussi, en mode d√©veloppeur : Programmation fonctionnelle ; Cr√©ation de package; Programmation orient√©e objet (S3); Introduction au package RCpp pour booster les ex√©cutions des codes R.

Nous disposions d'une totale libert√© dans le choix de sujet de notre projet, une approche qui visait √† stimuler notre engagement et √† encourager notre cr√©ativit√© (merci Remy).

Ce rapport retrace notre parcours tout au long de ce projet, une aventure pleine de d√©fi et ou on a failli s'arracher les cheveux √† de multiple reprise. La mise en place a n√©cessit√© une bonne dose d'organisation et de pers√©v√©rance.

Ce document sert √©galement de synth√®se, il va nous permettre de revenir sur les difficult√©s, les points forts et faibles de notre projet mais aussi de pr√©senter la strat√©gie mise en place.


## D√©but de notre projet

Nous avons d‚Äôabord cherch√© un sujet qui pouvait nous plaire √† toutes les deux. Apr√®s r√©flexion on a d√©cid√© de partir sur le sport en g√©n√©ral, Jade √©tant tr√®s sportive et moi qui adore regarder le sport √† la t√©l√© ! La gymnastique √©tant un sport que nous appr√©cions toutes les deux nous sommes donc parties sur cela. En discutant d‚Äôavantage une id√©e nous est venue : est -il possible de pr√©dire les prochaines m√©dailles olympiques aux JO 2028 en gymnastique ? 

Un m√©lange de ce que l‚Äôon aime toutes les deux et un d√©fi sympa √† r√©aliser (irr√©alisable finalement‚Ä¶)

Qui dis pr√©diction dis Machine Learning notre projet serait donc de cr√©er un algorithme de machine Learning dans le but de pr√©dire les prochaines m√©dailles au JO.

Au d√©but de notre projet on a vite r√©alis√© qu‚Äôil √©tait essentiel pour nous de trouver une base de donn√©es adapt√©e, contenant toutes les variables n√©cessaires pour r√©aliser notre projet et faire une classification. Notre premi√®re id√©e √©tait de cr√©er notre propre base de donn√©es. Ce qui aurait tr√®s int√©ressant pour avoir un contr√¥le sur les donn√©es dont on avait besoin, mais on s‚Äôest tr√®s vite rendu compte que cette t√¢che serait tr√®s compliqu√©e. Cr√©er une base de donn√©es avec toutes les variables dont nous avons besoin aurait √©t√© une perte de temps consid√©rable. De plus ce travail n‚Äôest pas adapt√© au cours dans le quelle nous somme mais plus √† un cours de base de donn√©es. Ce travail nous aurait pris plus de temps que de cr√©er le code, donc on a abandonn√© l‚Äôid√©e.

Pour gagner en efficacit√© sur ce projet, on a alors commenc√© nos recherches pour trouver une base de donn√©es d√©j√† existante. Nous avons explor√© plusieurs sites jusqu‚Äô√† ce que nous tombions sur une base de donn√©es Kaggle qui r√©pondait parfaitement √† nos besoins. Ce jeu de donn√©es contenait toutes les variables n√©cessaires pour construire notre mod√®le de classification. Ce qui nous a permis de nous concentrer sur la mod√©lisation, et l‚Äôimpl√©mentation d‚Äôalgorithmes.

## MedalsPrediction

Une fois la base de donn√©es choisie nous avons d√©cid√© d‚Äôutiliser Julia pour cr√©er notre algorithme de machine Learning. Julia √©tant un langage que nous connaissions peu, mais il nous l‚Äôa √©t√© vendu comme super performant alors quoi de mieux que Julia pour impl√©menter cet algorithme ! Nous avons vu ce projet comme une opportunit√© de nous familiariser avec Julia en appliquant des concepts de machine Learning, ce qui nous a permis d‚Äô√©largir nos comp√©tences et de d√©couvrir tous ses atouts.

Pour le choix de l‚Äôalgorithme, nous avons opt√© pour Random Forest. Cet algorithme est particuli√®rement r√©put√© pour sa robustesse et ses performances dans les taches de classification. Il fonctionne en combinant les pr√©dictions de plusieurs arbres ind√©pendant chacun √©tant construit sur un sous-√©chantillon al√©atoire des donn√©es. C‚Äôest cette robustesse qui a motiv√© notre choix.

Pour d√©buter a coder, la premi√®re √©tape a √©t√© de nettoyer la base de donn√©es. Cela m‚Äôa pris pas mal de temps car j‚Äôai voulu effectuer ce nettoyage √† la fois sur R et sur Julia, afin de comparer et de m‚Äôexercer sur les deux langages. J‚Äôai donc commenc√© par nettoyer une premi√®re base de donn√©es, mais j‚Äôai ensuite d√©couvert qu‚Äôelle ne contenait des r√©sultats que jusqu‚Äôen 2016, ce qui ne correspondait pas du tout √† ce que je voulais. 

Le nettoyage de la base de donn√©es a impliqu√© plusieurs √©tapes importantes. La base de donn√©es d‚Äôorigines √©tait tr√®s large et contenait des donn√©es pour tous les sports des Jeux olympiques. J‚Äôai donc commenc√© par filtrer les donn√©es pour ne conserver uniquement les lignes ou la gymnastique apparaissait comme discipline. Ensuite j‚Äôai restreint la p√©riode d‚Äôanalyse aux ann√©es 2008 et 2020 afin de pouvoir entrainer l‚Äôalgorithme.

Une autre √©tape assez importante a √©t√© le traitement de la variable m√©daille, comme cette variable contenait des valeurs manquantes, cela s‚Äôexpliquait par le fait que la personne sur la ligne n‚Äôavait pas gagn√© de m√©daille, j‚Äôai choisi de remplacer par une nouvelle cat√©gorie intitul√©e ¬´ no medals ¬ª pour bien signifier que le participant n‚Äôavait rien remport√©.

Par la suite j‚Äôai transform√© les cat√©gories textuelles gold, silver, bronze et no medals en valeur num√©rique (1, 2, 3 et 0 respectivement). Cette conversion est essentielle, car l‚Äôalgorithme Random Forest, travaille avec des donn√©es num√©riques et non textuelles. En transformant les cat√©gories en √©tiquettes num√©riques, j‚Äôai rendu la variable exploitable pour l‚Äôentrainement de notre mod√®le. 

Enfin, j‚Äôai √©galement modifi√© la variable event, qui contenait les noms des diff√©rents agr√©es de gymnastique. Ces noms √©taient souvent trop longs et en anglais, ce qui n‚Äô√©tait pas tr√®s pratique pour travailler et comprendre les donn√©es. J‚Äôai donc traduit les noms des disciplines en fran√ßais et je les ai remplac√©s par des termes correspondant aux agr√©es de gymnastique comme sol, poutre‚Ä¶ Cette √©tape avait pour but de rendre les donn√©es plus compr√©hensible et accessible pour l‚Äôutilisation.

Ce nettoyage a √©t√© donc une √©tape essentielle pour pr√©parer les donn√©es avant d‚Äôappliquer l‚Äôalgorithme de machine Learning. Il a permis de transformer une base de donn√©es pour la rendre pr√™te √† l‚Äôemploi.

Pour chaque √©tape du projet, on a d√©cid√© de cr√©er des fonctions sp√©cifiques. D‚Äôabord j‚Äôai √©crit une fonction pour nettoyer la base de donn√©es, puis une autre pour entrainer le mod√®le avec l‚Äôalgorithme Random Forest. C‚Äôest √† ce moment la que je me suis retrouv√© face √† une erreur que j‚Äôai mis √©norm√©ment de temps √† r√©soudre.

Mon probl√®me √©tait que je n‚Äôarrivais pas √† trouver une fonction qui me permettait de convertir toutes mes variables cat√©gorielles textuelles en variables num√©riques, tout en √©vitant l‚Äôimplication d‚Äôune relation d‚Äôordre entre les cat√©gories. Par exemple, l‚Äôalgorithme pourrait interpr√©ter que le fait de mettre femelle=1 et male =2, signifierait 1<2, mais ce n‚Äôest pas le cas.

C‚Äôest la qu‚Äôintervient la fonction One-Hot-Encoding. Cette fonction permet de convertir des cat√©gories textuelles en plusieurs colonnes binaires ind√©pendantes. Par exemple pour la variable sex, elle va cr√©er deux colonnes distinctes : sex_male, sex_female. Pour caque ligne de la base de donn√©es la colonne sex_male prendra 1 si la personne est un homme et 0 sinon et de m√™me pour la colonne sex_female. Cette transformation supprime toute notion d‚Äôordre implicite et est beaucoup mieux adapt√© pour l‚Äôalgorithme Random Forest, qui fonctionne avec des valeurs num√©riques.

Malheureusement pour moi la fonction de One-Hot-Encoding d√©j√† impl√©ment√©e sur Julia ne fonctionnait pas correctement dans mon code. J‚Äôai donc d√©cider de cr√©er ma propre fonction en m‚Äôinspirant de fonction trouv√©e sur internet. Apr√®s quelques essais et ajustement, j‚Äôai r√©ussi a obtenir une fonction op√©rationnelle.

La derni√®re fonction que j‚Äôai cr√©√©e permet d‚Äô√©valuer le mod√®le apr√®s l‚Äôentrainement, en calculant plusieurs scores d‚Äô√©valuation comme l‚Äôaccuracy, la pr√©cision et la matrice de confusion. Cela m‚Äôa permis de mieux comprendre les performances du mod√®le, qui n‚Äô√©tait pas tr√®s bonnes üòä 

Enfin l‚Äôune des derni√®res √©tapes de mon code consistait √† afficher les r√©sultats sous la forme suivante : je voulais lister, pour chaque cat√©gorie, le nom des athl√®tes ainsi que la m√©daille qu‚Äôils avaient remport√©e.

En ce qui concerne les r√©sultats, la bonne nouvelle est que j‚Äôarrive effectivement √† obtenir des pr√©dictions et √† faire tourner mon code, mais malheureusement, elles ne sont pas du tout satisfaisantes. Mon accuracy est tr√®s faible, ce qui signifie que le mod√®les ne parvient pas √† faire de bonnes pr√©dictions. Le principal probl√®me est que je re√ßois des r√©sultats dupliqu√©s. Par exemple, pour la cat√©gorie ¬´ barre asym√©trique ¬ª, le mod√®le pr√©dit deux voir trois personnes remportant la m√©daille d‚Äôor, ce qui est √©videmment impossible. Et parfois m√™me elle ne trouvait personne remportant la m√©daille d‚Äôor, il y avait des trous.

Je pense que l‚Äôalgorithme a appris que plusieurs personnes peuvent avoir la m√™me proba de gagner une m√©daille, sans comprendre qu‚Äôil ne peut y avoir qu‚Äôun seul gagnant par m√©daille dans chaque cat√©gorie. Ce probl√®me peut aussi venir du fait que ma base de donnes est relativement petite, apr√®s avoir √©l√©mine les lignes inutiles, je n‚Äôavais plus qu‚Äôune centaine de lignes, ce qui n‚Äôest pas du tout satisfaisant pour entrainer correctement un mod√®le de ce genre. Je pense que c‚Äôest ce qui a fait que parfois il ne me donnait personne pour la m√©daille d‚Äôor surement que les lignes avaient √©t√© supprim√©es.

Voici ce que j'obtiens:

```{julia}
using ProjetRJulia
using DataFrames
using MLJ

#On pr√©pare la base de donn√©e et on charge
filtered_data = ProjetRJulia.load_data2()

#Entrainement et predicton du mod√®le
model, y_test, y_pred=train_model2(filtered_data)

#Je veux dans mon r√©sultat, le nom, la m√©daille gagn√©e et dans quelle event 
prediction = DataFrame(Name = filtered_data.Name[partition(eachindex(filtered_data.Medal), 0.7)[2]], pred_Medal = y_pred, Event = filtered_data.Event[partition(eachindex(filtered_data.Medal), 0.7)[2]])

resultat_par_evnmt = groupby(prediction, :Event)

```

Au final, j‚Äôai compris que ce projet dans cette forme la, n‚Äô√©tait pas totalement r√©alisable, Le manque de donn√©es suffisantes et la difficult√© √† faire en sorte que l‚Äôalgorithme apprenne correctement ont limit√© la performance du mod√®le. Ca nous a permis de prendre conscience de l‚Äôimportance de la qualit√© et de la taille des donn√©es dans la cr√©ation d‚Äôun algorithme de machine Learning.

## BreastCancer

Histoire de quand m√™me avancer dans notre apprentissage du machine learning, de comprendre son fonctionnement et rendre un code assez potable, nous avons r√©fl√©chie a une alternative. Nous nous sommes mis d‚Äôaccord sur l‚Äôid√©e de r√©aliser deux algorithmes de Machine Learning : un pour la pr√©diction des m√©dailles (m√™mes si les r√©sultats ne sont pas bons) et un autre bas√© sur une autre base de donn√©es plus grande et plus fiable.

Nous avons donc d√©cider de cr√©er un autre algorithme sur une autre base de donn√©es, beaucoup plus grande cette fois. Pour ce deuxi√®me algorithme, nous avons choisi de travailler avec une base de donn√©es sur le cancer du sein. Le but ici √©tait d‚Äôobtenir de bons r√©sultats en termes d‚Äôaccuracy, de pr√©cision et d‚Äôautres m√©triques d‚Äô√©valuations. J‚Äôai donc nettoy√© cette base de donn√©es, puis entrain√© le mod√®le de Random Forest et √©valu√© la performance du mod√®le, exactement de la m√™me mani√®re que pour la pr√©diction de m√©daille et toujours sur Julia.

Apr√®s avoir obtenu les r√©sultats, nous nous sommes dit ¬´ Pourquoi pas comparer les performances de R et Julia en machine learning ? ¬ª.  J‚Äôai donc r√©√©crit un algorithme similaire en R et en utilisant le package caret et l‚Äôalgorithme Random Forest, pour comparer les r√©sultats avec ceux g√©n√©r√©s par Julia. Comme on le pressentais, les r√©sultats √©taient meilleurs avec Julia. En effet, pour les m√™mes hyperparam√®tres et les m√™mes donn√©es d‚Äôentr√©e, les performances du mod√®le en Julia √©taient meilleures en termes d‚Äôaccuracy, de pr√©cision et des autres m√©triques d‚Äô√©valuation.
Voici les performances en Julia:

```{julia, echo=false}

using ProjetRJulia

#Charger le dataset
data = ProjetRJulia.load_data()

#Entrainement et predicton du mod√®le pour le cancer du sein
model, y_test, y_pred=train_model(data)

accuracy, cm, recall_score, f1_score = evaluate_model(y_test, y_pred)
```

Pour moi, la principale raison de cette diff√©rence r√©side dans la nature des langages. R est un langage interpr√©t√©, ce qui signifie que chaque ligne de code est traduite et ex√©cut√©e √† la vol√©e par l‚Äôinterpr√©teur. √áa peut entrainer des ralentissements, surtout quand il s‚Äôagit de tache intensive comme la cr√©ation des arbres de d√©cision. Julia lui est un langage compil√© √† la vol√©e, ce qui lui permet d‚Äôex√©cuter des codes plus rapidement et plus efficacement. Cette diff√©rence de fonctionnement a donc un impact direct sur les performances, particuli√®rement pour des algorithmes de machine Learning qui n√©cessitent des calculs r√©p√©titifs sur de grandes quantit√© de donn√©es
Donc pour mon code, Julia a montr√© de meilleures performances en machine Learning.

## Visualisations

J‚Äôai essay√© de faire quelques visualisations sur R et Julia. L‚Äôid√©e √©tait de faire de graphique comme des histogrammes et d‚Äôautres visualisation que nous allons ins√©rer par la suite dans notre application shiny. 

Voici quelques exemples de visualisations faites:

```{julia, include=FALSE}
using ProjetRJulia
using DataFrames
using Plots
using StatsPlots

gr()

#Charger le dataset
data = ProjetRJulia.load_data()

p1=histogram(data.radius_mean,title="Histogramme radius_mean", xlabel="radius_mean", ylabel="Fr√©quence", legend=false)

p2=histogram(data.area_mean,title="Histogramme area_mean", xlabel="area_mean", ylabel="Fr√©quence", legend=false)

p3=violin(data.symmetry_mean, title="Violinplot de symmetry_mean", xlabel="symmetry_mean", ylabel="Category", legend=false)

p4=violin(data.texture_mean, title="Violinplot de texture_mean", ylabel="texture_mean", xlabel="Category", legend=false)

color_map = Dict(0 => :red, 1 => :blue)

p5=boxplot(data.diagnosis, data.area_se, title="Boxplot of area_se by Diagnosis", xlabel=["B√©nin","Malin"], ylabel="area_se", legend=false)

p6=boxplot(data.diagnosis, data.concavity_worst, title="Boxplot of concavity_worst by Diagnosis", xlabel=["B√©nin","




Malin"], ylabel="concavity_worst", legend=false)

# Afficher les graphiques dans un layout
plot(p1, p2, p3, p4, p5, p6, layout=(3, 2),size=(1000, 800))

```



J‚Äôai aussi essay√© de me servir de Rulia pour quand m√™me essayer un petit peu mais j‚Äôai beaucoup de mal √† comprendre et avec tout les autres probl√®mes qui sont apparus je n‚Äôai pas bien eu le temps de m‚Äôy int√©resser plus.


## Shiny

Pour commencer le Shiny, comme nous ne connaissions pas, nous commen√ßons par √©crire les premi√®res questions qui nous viennent qui sont en g√©n√©rale tr√®s basiques mais qui permettent de construire la base de nos recherches √† venir :

- A quoi ca sert ? :
Pour commencer, Shiny est un package R d√©velopp√© par RStudio qui permet de cr√©er des applications web interactives directement depuis le langage R. Ces applications sont particuli√®rement utiles pour des visualisations de donn√©es, des analyses interactives.

Principales caract√©ristiques de Shiny :

‚Üí Interaction dynamique : Shiny permet de cr√©er des applications o√π l'utilisateur peut interagir avec les graphiques et les r√©sultats en temps r√©el (par exemple, filtrer des donn√©es, ajuster des param√®tres, etc.).

‚Üí Facilit√© d'utilisation : Il est con√ßu pour √™tre utilis√© directement par des statisticiens et des data scientists sans qu'ils aient besoin de ma√Ætriser des technologies web comme HTML. La syntaxe est relativement simple pour les utilisateurs familiers avec R.

‚Üí Int√©gration avec R : Il peut √™tre utilis√© avec tous les packages et fonctions R, ce qui permet de r√©aliser des analyses de donn√©es complexes et d'afficher les r√©sultats dans une interface web interactive.

D√©ploiement de l'application :

Une fois que l‚Äô application Shiny est cr√©e, il est possible de la d√©ployer de plusieurs fa√ßons :

‚Ä¢	Localement : Ex√©cuter une application Shiny sur son propre ordinateur.

‚Ä¢	Sur un serveur : Utiliser des services comme shinyapps.io (service en ligne de RStudio) pour d√©ployer des applications Shiny sans n√©cessiter de serveur.

‚Ä¢	Serveur RStudio : D√©ployer une application sur votre propre serveur RStudio.

-Comment ca marche ?

Shiny fonctionne en combinant deux √©l√©ments principaux : l'interface utilisateur (UI) et la logique c√¥t√© serveur. Lorsqu‚Äôon ex√©cute une application Shiny, l'interface est g√©n√©r√©e et affich√©e dans un navigateur web, et les interactions de l'utilisateur (comme les clics ou les ajustements de param√®tres) sont envoy√©es au serveur pour traiter les donn√©es, puis les r√©sultats sont renvoy√©s √† l'utilisateur.

Plus en d√©tails :

Une application Shiny est compos√©e de deux parties principales :

‚Ä¢	L'interface utilisateur (UI) : C'est ce que l'utilisateur voit dans le navigateur. Cela inclut les boutons, les champs de texte, les graphiques et tout autre √©l√©ment visuel de l'application.

‚Ä¢	Le serveur : C'est la partie qui contient la logique. Elle prend en charge les calculs, l'analyse des donn√©es, et la mise √† jour dynamique de l'interface utilisateur en fonction des entr√©es de l'utilisateur.

1.	Lancer l'application : Lorsqu'une application Shiny est lanc√©e, le serveur et l'interface utilisateur sont charg√©s en m√™me temps.

‚Ä¢	L'interface utilisateur d√©finit la structure (disposition des √©l√©ments interactifs).

‚Ä¢	Le serveur contient la logique pour traiter les actions de l'utilisateur.

2.	Interaction avec l'interface : L'utilisateur interagit avec l'interface, par exemple en ajustant un curseur, en s√©lectionnant une option dans une liste d√©roulante, ou en cliquant sur un bouton.

‚Ä¢	Ces actions g√©n√®rent des entr√©es qui sont envoy√©es au serveur.

3.	Traitement des entr√©es par le serveur : Le serveur re√ßoit les entr√©es, les traite (en effectuant des calculs, en g√©n√©rant des graphiques, en filtrant les donn√©es, etc.), et renvoie les sorties.

‚Ä¢	Les sorties sont g√©n√©ralement des graphiques, des tableaux, ou des textes qui sont mis √† jour dans l'interface utilisateur.

4.	Rafra√Æchissement de l'interface : L'interface utilisateur se met √† jour en fonction des nouvelles donn√©es ou des r√©sultats fournis par le serveur. Ce processus est dynamique et en temps r√©el.

- Quels avantages ?

1.	Interactivit√© .
2.	Accessibilit√©
3.	Facilit√© d'int√©gration avec R : il est possible d‚Äôutiliser toutes les fonctionnalit√©s de R dans une application Shiny, qu'il s'agisse de visualisations (ggplot2, plotly), d'analyses statistiques, ou de traitement de donn√©es.

Globalement, Shiny est tr√®s bien pens√© pour partager des r√©sultat, faire une pr√©sentation interactive, rassembler des connaissances dans une interface ludique et simple d‚Äôutilisation.
Une fois r√©pondu √† ces questions nous avons donc chercher de la documentation pour savoir par ou commencer le code et surtout quel type de theme le Shiny prendrait.

Pendant les s√©ances qui suivent, on travaille en parall√®le sur la cr√©ation  de la base de donn√©es et le d√©veloppement du futur Shiny qui contiendra tout les r√©sultats du machine learning.
Le code que j‚Äôai regard√© (trouv√© sur github) montre un d‚Äôinteraction avec le shiny via des ¬´ bouton ¬ª. En regardant le code de github, je vois  qu‚Äôil est posssible de faire appara√Ætre des ¬´ sous boutons ¬ª en cliquant sur le bouton principal.

Je code alors Trois boutons principaux :
- Homme
- Femme
- Pays
qui sont globalement les pr√©vision que l‚Äôon veut faire. Ensuite j‚Äôajoute les sous-boutons qui devront appara√Ætre qu‚Äôune fois que l‚Äôutilisateur √† cliqu√© sur un bouton principal.

Pour ¬´ Homme ¬ª j‚Äôajoute les sous-boutons correspondant aux agt√®s masculin ainsi que le sous-bouton ¬´ individuel ¬ª et ¬´ par  √©quipe ¬ª, de m√™me pour ¬´ Femme ¬ª et je laisse le bouton ¬´ Pays ¬ª vide pour l‚Äôinstant.

Probl√®mes :

 ‚Üí Dans un premier temps, lorsque le Shiny se lance les sous-boutons n‚Äôapparaissent pas. Apr√®s quelques recherches, j‚Äôai pu les faire appara√Ætre en utilisant ¬´ observEvent ¬ª qui permet de faire appara√Ætre un bouton secondaire lorsque le principale est cliqu√©.

‚Üí Un deuxi√®me probl√®me appara√Æt alors : lorsque que je clique sur les sous boutons la page ne change pas et n‚Äôaffiche pas la phrase de test que j‚Äôai mis dans le code. Je n‚Äôai pas trouv√© de probl√®me (donc pas de solution) du c√¥t√© des sous boutons. D√©sesp√©rant un peu j‚Äôai demand√© de l‚Äôaide √† un ami bien connu : ¬´ Chat GPT ¬ª. En fait je n‚Äôavais pas si bien compris le fonctionnement de ¬´ renderUI ¬ª et ¬´ updateUI ¬ª en en mettant plusieurs dans le code‚Ä¶

‚Üí Malgr√© tout des probl√®mes persistent. Par exemple, on ne peut plus revenir sur une autre page apr√®s avoir cliqu√© sur un sous-bouton (entre autre). Apr√®s 2 ou 3 s√©ances √† essayer de r√©soudre ces probl√®mes, j‚Äôai d√©couvert https://rstudio.github.io/shinydashboard/ ! (Merci R√©my!)
Depuis lors, on d√©cide de tout recommencer avec pour base ce que pr√©sente shiny dashboard. On reconstruit donc la structure √©nonc√©e pr√©c√©demment. Mais avec Emma on estime qu‚Äôon a pass√© assez de temps √† cr√©er le shiny et comprendre comment √ßa marchait, qu‚Äôil fallait prioriser la suite du projet.

Update :
Le machine learning sur la gymnastique ayant √©chou√©, nous avons r√©utilis√© la structure du premier Shiny pour en faire un deuxi√®me. Ce nouveau Shiny est assez simple. Il a globalement la m√™me structure que que le pr√©c√©dent il y a quelques graphiques, ceux obtenus avec la nouvelle base de donn√©es qui nous a servie √† tester le machine learning.
Ce Shiny est la derni√®re chose qui a √©t√© faite dans le projet, nous n‚Äôavons pas eu le temps de le travailler dans le d√©tail.

## CART en Julia

Pendant qu‚ÄôEmma fait du machine learning, en R puis en Julia, je me motive √† apprendre Julia √† mon tour. L‚Äôid√©e est de commencer un algorithme CART (Classification And Regression Trees) en Julia pour apprendre la syntaxe de ce nouveau langage.

Cette partie du projet correspond √† mes premiers pas en Julia, langage que je n'avais jamais utilis√© auparavant. L'algorithme rpart en R (Recursive Partitioning and Regression Trees) va me servir de guide, c‚Äôest un mod√®le d'arbres de d√©cision utilis√© pour des t√¢ches de r√©gression et de classification. Il fait partie des outils standards en R pour l‚Äôanalyse des donn√©es et est bas√© sur l‚Äôalgorithme CART (Classification And Regression Trees).
Grace √† Rstudio je ressors la liste des fonctions que rpart, en selectionne quelques unesnqui me paraissent abordables pour commencer. Et c‚Äôest parti !

L‚Äôobjectif principal de ce projet √©tait de :
1.	Reproduire quelques fonctionnalit√©s de l'algorithme rpart dans le langage Julia.
2.	Apprendre et comprendre le langage Julia, en particulier ses particularit√©s par rapport √† R.

Apprentissage de la syntaxe de Julia:

Avant de commencer √† travailler sur le projet proprement dit, j'ai d√ª consacrer une partie de mon temps √† l'apprentissage du langage Julia, car il s'agissait de mon tout premier projet dans ce langage. Julia est un langage relativement r√©cent, con√ßu pour les calculs num√©riques de haute performance et utilis√© principalement dans le domaine de la science des donn√©es, des math√©matiques et de l'analyse statistique mais comporte beaucoup d‚Äôautres facult√©s et peut se r√©v√©ler utile et performent dans d‚Äôautre domaine.

Le langage Julia se distingue de R par sa syntaxe plus proche de celle des langages de programmation tels que Python ou C (au moins sur la forme), sa gestion efficace de la m√©moire et ses performances exceptionnelles pour des t√¢ches computationnelles lourdes et le multiple dispaching.  

Au commencement on utilise ¬´ mutable struct ¬ª pour d√©finir les n≈ìuds :
En Julia, un mutable struct est une structure de donn√©es qui permet de modifier ses champs apr√®s sa cr√©ation. Ce type de structure est utilis√© pour repr√©senter des objets dont l'√©tat peut √™tre modifi√©, ce qui est souvent n√©cessaire dans des algorithmes et c‚Äôest le cas pour la construction d'arbres de d√©cision.

Mutable Struct √©tant une notion nouvelle, voici ce que nous avons compris :

1. Modification des champs de la structure pendant l'ex√©cution
Dans un arbre de d√©cision, chaque n≈ìud de l'arbre peut √™tre soit une feuille, soit un n≈ìud interne ayant des sous-arbres. L'√©tat de chaque n≈ìud (par exemple, les caract√©ristiques utilis√©es pour le split, le seuil de s√©paration, le label ou la valeur de la feuille) peut changer au fur et √† mesure que l'algorithme de construction de l'arbre progresse.

‚Ä¢	Exemple :
Au fur et √† mesure de l'algorithme de construction de l'arbre, il faut mettre √† jour des informations comme feature, threshold, ou impurity pour chaque n≈ìud. Avec un mutable struct, ces champs peuvent √™tre modifi√©s en place pendant la construction de l‚Äôarbre.

2. Efficacit√© des op√©rations
En Julia, les structures immuables (cr√©√©es avec struct) sont souvent utilis√©es pour des objets dont les valeurs ne changent pas apr√®s leur cr√©ation. Cela permet √† Julia de mieux optimiser la m√©moire et les performances pour des types immuables. Cependant, pour des objets comme les n≈ìuds d'un arbre de d√©cision, o√π on a besoin de manipuler activement les valeurs au cours de l'ex√©cution de l'algorithme, un mutable struct est pr√©f√©rable.

3. Recursion sur l'arbre de d√©cision
Les algorithmes de construction d'arbres de d√©cision, comme CART, reposent sur la r√©cursion pour parcourir les n≈ìuds et diviser les donn√©es. Chaque n≈ìud peut contenir un sous-arbre gauche et un sous-arbre droit, et ces sous-arbres peuvent √™tre modifi√©s √† chaque it√©ration.

‚Ä¢	Exemple :
Dans la fonction qui construit l'arbre, chaque n≈ìud doit avoir des sous-arbres qui peuvent √™tre assign√©s √† ses champs left et right au fur et √† mesure que l'algorithme divise les donn√©es. Ces sous-arbres peuvent √™tre de nouveaux n≈ìuds, et √©tant donn√© que l‚Äôarbre est modifi√© en place, un mutable struct est essentiel pour cela.

Probl√®mes rencontr√©s:

1. Compr√©hension du fonctionnement de rpart
Le premier obstacle majeur rencontr√© a √©t√© de bien comprendre l‚Äôimpl√©mentation interne de l'algorithme rpart en R. L'algorithme repose sur une s√©rie de crit√®res statistiques (tels que la r√©duction de l'impuret√©) pour diviser r√©cursivement les donn√©es. La premi√®re √©tape a donc √©t√© de d√©cortiquer l'algorithme.

Pour cette √©tape, j‚Äôai consult√© la documentation de rpart et des ressources en ligne pour mieux comprendre les concepts sous-jacents des arbres de d√©cision, comme la fonction splitter et l‚Äôutilisation de crit√®res comme le Gini Index ou la moyenne des carr√©s des erreurs. J'ai aussi examin√© plusieurs impl√©mentations d'arbres de d√©cision en R pour me familiariser avec la mani√®re dont les d√©cisions sont prises au sein de l'algorithme m√™me si au final je n‚Äôai pas s√©lectionn√© tous ce qui est √©nonc√© au ci-dessus.


2. Probl√®me :
La fonction pour construire l'arbre de d√©cision (labels_node) implique une r√©cursivit√© pour explorer les sous-arbres gauche et droit. J'ai rencontr√© un probl√®me avec la r√©cursivit√©, notamment lors de la gestion des n≈ìuds de type Nothing, ce qui m‚Äôa forc√© √† revoir ma logique pour m'assurer que la fonction soit robuste √† ces cas-l√†.

Solution mise en place :
J'ai d√ª ajouter des v√©rifications explicites pour garantir que les sous-arbres gauche et droit √©taient bien d√©finis avant d'appeler r√©cursivement la fonction labels_node


3. Difficult√© √† choisir et impl√©menter le crit√®re de s√©paration (impuret√© de Gini)
Probl√®me :
Le crit√®re de s√©paration utilis√© dans rpart pour diviser les n≈ìuds est l‚Äôimpuret√© de Gini. Bien que le calcul de l‚Äôimpuret√© de Gini soit relativement simple en th√©orie, la mise en ≈ìuvre en Julia m‚Äôa pos√© quelques difficult√©s. Au d√©part, j‚Äôai eu du mal √† optimiser cette fonction et √† m'assurer que l'indexation des classes √©tait correcte.
Le d√©fi r√©sidait dans la gestion de l‚Äôindexation des labels et dans le calcul de la probabilit√© de chaque classe dans un sous-ensemble donn√©.

Solution  :
J‚Äôai d‚Äôabord √©crit une fonction de base qui calcule l'impuret√© de Gini, puis j‚Äôai v√©rifi√© plusieurs fois les valeurs des probabilit√©s en utilisant des impressions de d√©bogage. J‚Äôai pris soin de g√©rer les divisions par z√©ro, ce qui peut survenir si une classe n‚Äôest pr√©sente que dans une seule branche du sous-ensemble.

Conclusion:

Voici ce que je retiens de Julia dans mon apprentissage : 
Pas de notion d'attributs
Julia n‚Äôutilise pas explicitement la notion d'attributs d'objets comme on le voit en orient√© objet classique (par exemple en Python). Toutefois, Julia adopte un mod√®le de programmation orient√©e objet (OOP) bas√© sur des types composites et des m√©thodes surcharg√©es. Ce mod√®le est plus flexible et moins contraignant que l‚ÄôOOP traditionnel d'autres langages, ce qui peut le rendre plus adapt√© √† certains types de projets.

Les principaux points communs:

1.	Syst√®me bas√© sur des appels de fonctions : Tant R que Julia sont bas√©s sur un syst√®me o√π les fonctions sont des objets de premi√®re classe et peuvent √™tre pass√©es comme arguments, retourn√©es et stock√©es dans des variables.


2.	Structures vectorielles et matricielles avec op√©rations associ√©es : Les deux langages permettent de travailler avec des structures vectorielles, matricielles et des op√©rations vectoris√©es de mani√®re native. Julia, cependant, est plus rapide dans le traitement de ces structures en raison de son optimisation √† la compilation, tandis que R n√©cessite souvent des appels aux biblioth√®ques comme data.table ou dplyr pour des performances optimales.
Mode Lisp-like avec expression : Julia s'inspire largement de Lisp en termes de manipulation d'expressions, ce qui permet une flexibilit√© de traitement et de m√©taprogrammation plus pouss√©e. R, bien qu‚Äôayant des aspects de ce mod√®le via des objets et des appels de fonctions, n‚Äôest pas aussi puriste dans cette approche.

√Ä la fois interpr√©t√© et performant, il combine la flexibilit√© d'un langage de haut niveau avec des performances proches de celles des langages compil√©s, notamment gr√¢ce √† son m√©canisme de compilation Just-In-Time (JIT). Ce m√©canisme g√©n√®re du code pr√©compil√© en C avant l'ex√©cution, permettant ainsi d'√©viter l'overhead typique des langages interpr√©t√©s, tout en √©liminant la n√©cessit√© d'√©crire du code C++ comme dans R avec Rcpp.

L'un des points forts de Julia est son interfa√ßage natif avec C, ce qui permet une interaction directe avec des biblioth√®ques externes sans n√©cessiter de biblioth√®ques interm√©diaires, simplifiant ainsi l'int√©gration de composants C dans les programmes Julia. Julia combine aussi des structures de donn√©es immutables et mutables, offrant une grande flexibilit√© dans la gestion de la m√©moire et des performances, tout en permettant d‚Äôexploiter au mieux les capacit√©s de calcul parall√®le d√®s le d√©part.

Le langage met l‚Äôaccent sur une approche modulaire avec un syst√®me de packages unifi√©, semblable √† celui de R, qui facilite l‚Äôinstallation et l‚Äôutilisation des biblioth√®ques tierces. En termes d‚Äôinteractivit√©, Julia offre un mode utilisateur avec un typage dynamique et un environnement REPL, permettant aux utilisateurs de travailler de mani√®re intuitive.
Pour les d√©veloppeurs, Julia se distingue par son mod√®le de programmation orient√©e objet bas√© sur le concept de multiple dispaching. Cette approche permet de d√©finir plusieurs m√©thodes pour un m√™me nom de fonction, selon les types des arguments, ce qui rend le code plus flexible et lisible tout en restant performant. Contrairement aux classes traditionnelles, Julia d√©finit des types qui peuvent √™tre cr√©√©s par les utilisateurs, ce qui s'int√®gre parfaitement dans une hi√©rarchie de types pr√©d√©finis.

Rapidement, je me suis lass√©e de coder des fonctions ici et l√†. C‚Äô√©tait tr√®s instructifs, plut√¥t efficace pour apprendre la syntaxe de Julia, le fait d‚Äô√™tre guid√©e permettait d‚Äôapprendre pas √† pas, de savoir pr√©cis√©ment quelle notion chercher.

Le projet m‚Äôa donc permis de non seulement apprendre Julia, mais aussi de mieux comprendre l'impl√©mentation des algorithmes d'arbres de d√©cision, en particulier l'algorithme CART. Cette partie du projet aura pris plusieurs s√©ances, le pus long a √©t√© de trouver par o√π commencer, de faire les premiers pas dans le langage, de trouver des fonctionnalit√©s int√©ressantes pour optimiser ou r√©ussir certaines fonctions. On aurait pu continuer longtemps √† recoder rpart en Julia, il reste beaucoup de fonctions non exploit√©es, mais une fois que l‚Äôon a compris le fonctionnement de Julia, on a envie de s‚Äôamuser un peu plus √† Coder (oui avec un grand C) qu‚Äô√† recoder. D‚Äôo√π la partie suivante qui repose sur une tentative de mini jeu en Julia ET en R afin de comparer les deux langages mais cette fois ci en partant de 0.

## Snake Game

Au moment o√π l‚Äôon d√©cide de faire du Julia d‚Äôun point de vue d√©veloppement, il ne reste plus que 3 s√©ances. Conscientes que nous n‚Äôarriverons pas √† un mini-jeu aboutit on prend alors la d√©cision de faire une comparaison entre R et Julia sur ce mini-jeu qui serait le Snake.

### Snake en R (r√©sum√© rapide)

Pour commencer on se dit qu‚Äôil serait int√©ressant de le faire dans un shiny (Une pierre deux coups)  pour afficher le jeu.
Coder le serpent ainsi que le ¬´ plateau ¬ª de jeu se r√©v√®lent assez simple, les afficher dans  l‚Äôapp shiny √©galement. Mais apr√®s quelques heures, des essais infructueux (et quelques nerfs pass√©s) impossible de faire bouger le serpent dans l‚Äôapp Shiny.

Emma sugg√®re alors d‚Äôutiliser ggplot2 pour l‚Äôafficher. L√† encore, pas mal de temps pass√© sur ce passage, tr√®s facile d‚Äôafficher le serpent mais toujours pas de mouvement.

Le temps nous manquant, on d√©cide de changer rapidement de strat√©gie. Je me renseigne sur le codage d‚Äôun snake en python pour pouvoir comparer (et parce qu‚Äôil est beaucoup plus facile de trouver des vid√©os de snake cod√©s en python qu‚Äôen R). Sur une vid√©o Youtube, ils lancent le snake dans un terminal. On s‚Äôinspire alors de cette technique, le r√©sultat est moins beau mais √† pour avantage de fonctionner.

√áa ne ressemble pas encore √† grand-chose, mais c'est un d√©but.
Le serpent avant avance mais uniquement lorsque le bouton ‚Äòentrer‚Äô est tap√© et on ne peux pas changer de direction.

Apr√®s plusieurs heures √† essay√© de trouver une solution on d√©cide d‚Äôarr√™ter l√† pour R. Clairement Rstudio ne semblait pas adapt√©, nos id√©es pour faire fonctionner le code ne tarissent pas, pour autant nos essais restent infructeux. Dans un jeu comme Snake, on a besoin de g√©rer des √©v√©nements en temps r√©el, comme la d√©tection des touches appuy√©es (pour changer la direction du serpent). R n'a pas de support natif pour la gestion d'√©v√©nements comme le clavier, ce qui complique la gestion des interactions utilisateurs en temps r√©el. On a aussi pu constater que l'affichage graphique dans R est principalement destin√© √† des graphiques statiques ou interactifs pour l'analyse de donn√©es. 

Bien que l‚Äôon puisse dessiner des formes simples avec des fonctions comme plot() ou points(), ces outils ne sont pas con√ßus pour des animations fluides.

On d√©cide d‚Äôavancer malgr√© tout et de passer au code de Snake en Julia. Avec la derni√®re s√©ance qu‚Äôil nous reste, on aimerait arriv√© au m√™me niveau avec ce nouveau Snake qu‚Äôavec celui cod√© en R pour pouvoir comparer ce que l‚Äôon trouve .

### Snake en Julia

Le d√©but est assez simple. Pour pouvoir comparer, on d√©cide d‚Äôafficher le Snake sur le terminal comme pour R. Il suffit alors de ¬´ traduire ¬ª le code fait avant en R en Julia. Le d√©but (pour afficher le serpent) est donc assez rapide .

Maintenant pour le faire avancer :

Dans le code, l'avancement du serpent est g√©r√© principalement par la fonction move_snake(snake::AbstractSnake), qui met √† jour la position du serpent en fonction de sa direction actuelle.

-  Lire la direction actuelle du serpent
La direction actuelle du serpent est stock√©e dans l'attribut snake.direction de l'objet Snake. Au d√©part, cette direction est d√©finie √† 'D', ce qui correspond √† "droite".

- Obtenir le vecteur de direction
Dans la fonction move_snake, la direction du serpent est utilis√©e pour d√©terminer son mouvement. Les directions sont d√©finies dans un dictionnaire DIRECTIONS :

Chaque cl√© (comme 'Z', 'S', 'Q', 'D') est associ√©e √† un tuple (dx, dy), repr√©sentant le d√©placement sur l'axe horizontal (dx) et l'axe vertical (dy). 

Par exemple :
‚Ä¢	'Z' (haut) : (0, -1) ‚Üí il ne bouge pas horizontalement (0), mais se d√©place de -1 sur l'axe vertical (vers le haut).
‚Ä¢	'S' (bas) : (0, 1) ‚Üí il ne bouge pas horizontalement (0), mais se d√©place de +1 sur l'axe vertical (vers le bas).
‚Ä¢	'Q' (gauche) : (-1, 0) ‚Üí il se d√©place de -1 sur l'axe horizontal (vers la gauche) et reste au m√™me niveau verticalement (0).
‚Ä¢	'D' (droite) : (1, 0) ‚Üí il se d√©place de +1 sur l'axe horizontal (vers la droite) et reste au m√™me niveau verticalement (0).

- Calculer la nouvelle position de la t√™te:
Dans la fonction move_snake(snake::AbstractSnake), la t√™te du serpent est r√©cup√©r√©e en prenant le premier √©l√©ment du corps (snake.body[1]), qui est un tuple (x, y) repr√©sentant les coordonn√©es de la t√™te.

- Mettre √† jour le corps du serpent:
Une fois que la nouvelle position de la t√™te est calcul√©e, le corps du serpent est mis √† jour. La nouvelle position de la t√™te (calcul√©e dans new_head) est ajout√©e au d√©but du corps (new_head; snake.body[1:end-1]), ce qui fait avancer le serpent d'une case. Le corps du serpent (sauf la t√™te) est d√©cal√© d'une position vers l'avant.

Pendant 2 jours nous avons eu un probl√®me : Le serpent ne tournait que vers la droite ! Le probl√®me venait de la fonction  new_head qui r√©sultait de la ¬´ traduction ¬ª du code en R. Une fois remani√©e comme √©nonc√© ci-dessus le serpent tournait correctement.

3. G√©rer les collisions avec les directions oppos√©es
Il faut penser √† ce que le serpent ne puisse pas faire un demi-tour, c'est-√†-dire aller directement dans la direction oppos√©e. Par exemple, si le serpent va √† droite, il ne doit pas pouvoir imm√©diatement aller √† gauche (cela cr√©erait une collision avec lui-m√™me). C'est ce qui est g√©r√© dans le bloc handle_input, o√π il v√©rifie que la nouvelle direction n'est pas oppos√©e √† la direction actuelle.

Normalement cette sp√©cificit√© est bien impl√©ment√©e, on ne perd pas la partie en faisant un demi-tour, on ne peut simplement pas le faire.
Bon, il reste tout de m√™me un probl√®me, lorsqu‚Äôon veut faire un demi-tour, comme ce n‚Äôest pas possible, le serpent avance tout de m√™me d‚Äôune case par d√©faut...personne n‚Äôest parfait...


4. Les probl√®mes non r√©solus‚Ä¶.

Malheureusement, cette partie du projet ayant commenc√©e sur le tard nous n‚Äôavons pas eu le temps de le mener √† terme, sans aucun probl√®me avec un jeu ayant une interface int√©ressante etc...Apr√®s ce n‚Äôen √©tait pas le but sp√©cialement mais rendre un travail √† moiti√© fini reste frustrant.
Je lance le code, et le serpent avance‚Ä¶ mais, √ßa reste saccad√© √† cause de cette touche ¬´ ENTRER ¬ª qu‚Äôil faut taper entre chaque commande et sans laquelle le serpent n‚Äôavance pas. Ce n‚Äôest pas fluide. L‚Äôid√©e √©tait d‚Äôajouter une notion de temps au code permettant de dire par exemple ¬´ je veux que le serpent avance d‚Äôune position toutes les demi-seconde ¬ª.

Voici quelques tests que j‚Äôai r√©alis√©s :

Tentative 1 :
1.	Gestion du temps avec now() :
‚Ä¢	Utilisation de now() de la biblioth√®que Dates pour mesurer le temps √©coul√© depuis le dernier mouvement du serpent.

‚Ä¢	Le serpent avancerait toutes les secondes, contr√¥l√© par la condition if current_time - last_move_time >= Second(1).

2.	Am√©lioration de la boucle de jeu :
‚Ä¢	La boucle de jeu continue √† lire l'entr√©e utilisateur tout en avan√ßant le serpent toutes les secondes. L'entr√©e utilisateur ne bloque plus la boucle et permet de changer la direction √† tout moment.

3.	sleep(0.05) :
‚Ä¢	Un petit d√©lai pour r√©duire la charge CPU, mais sans bloquer la boucle principale qui g√®re l'affichage et les mouvements.
Malheureusement cela ne fonctionne pas √† faire avancer le serpent tout seul.

Tentative 2 :
‚Ä¢	Le probl√®me majeur est li√© √† l‚Äôutilisation de now() dans le contexte de gestion de temps, ce qui n'est pas aussi simple que de calculer l'√©cart en secondes avec now(). On tente alors une approche plus stable en combinant sleep() et un m√©canisme pour d√©placer automatiquement le serpent √† intervalle r√©gulier.

Potentielle solution:
Nous rempla√ßons l'usage de now() pour le contr√¥le du timing par une variable qui suit l'√©tat du jeu et met √† jour les mouvements du serpent √† intervalles r√©guliers, sans bloquer la lecture de l‚Äôentr√©e clavier.

Modifications principales :
1.	Utiliser une simple variable last_move_time pour g√©rer l'intervalle de mouvement.
2.	V√©rifier si le temps √©coul√© depuis le dernier mouvement est sup√©rieur √† une seconde avant de d√©placer le serpent.

Il y a eu encore plusieurs autres tentatives sans aucun r√©sultats satisfaisant sauf apparition de nouveaux bugs sur le d√©placement du serpent, nous d√©cidons donc reprendre l‚Äôancien code et essay√© de rendre plus intuitif et fluide le d√©placement du serpent. En commen√ßant par faire avanc√© le serpent juste avec les touches directionnelles sans avoir √† appuyer sur entrer

Le probl√®me vient du fait que readline attend que l'utilisateur appuie sur "Entr√©e" avant de r√©cup√©rer la commande, ce qui bloque l'ex√©cution du jeu pendant ce temps. Pour r√©soudre cela, il faudrait utiliser une fonction permettant de lire l'entr√©e clavier de mani√®re non-bloquante, c'est-√†-dire que le programme continue √† tourner sans attendre que l'utilisateur appuie sur "Entr√©e".

Une solution pour cela est d'utiliser la biblioth√®que Terminal de Julia, qui permet de lire les touches press√©es de mani√®re non-bloquante.

Mais le probl√®me persiste et viendrait potentiellement du fait que la boucle principale du jeu ne prend pas en compte de mani√®re fiable le passage du temps pour d√©placer le serpent toutes les secondes. Actuellement, le code essaie de v√©rifier si une seconde est pass√©e √† l'int√©rieur de la boucle, mais l'appel √† time() dans la condition if time() >= time_to_move n'est pas fiable dans un environnement interactif, car le programme attend une entr√©e de l'utilisateur. Cela  interf√©rerait avec la gestion du temps et ne pas permettre au serpent d'avancer comme pr√©vu.

Modifications principales :
1.	Remplacer la gestion du temps √† l'int√©rieur de la boucle par un contr√¥le du temps plus simple.
2.	S'assurer que le serpent avance toutes les secondes sans d√©pendre de l'attente de l'entr√©e de l'utilisateur.


Explication des changements :
1.	T√¢che asynchrone pour avancer le serpent :
‚Ä¢	La fonction advance_snake! est une t√¢che asynchrone (@async) qui avance le serpent d'une case toutes les secondes en utilisant sleep(1).

‚Ä¢	La r√©f√©rence mutable snake_ref est utilis√©e pour que cette t√¢che puisse modifier le serpent dans la boucle de jeu principale sans bloquer l'ex√©cution du programme.

2.	Gestion de l'entr√©e utilisateur :
‚Ä¢	Pendant que la t√¢che asynchrone avance le serpent, la boucle principale du jeu est d√©di√©e √† la gestion de l'entr√©e utilisateur (changement de direction, quitter le jeu, etc.) et √† la v√©rification des collisions.

3.	R√©f√©rence mutable pour le serpent :
‚Ä¢	En utilisant Ref(snake) pour la variable snake, nous permettons √† la t√¢che asynchrone d'acc√©der et de modifier directement l'√©tat du serpent tout en √©tant utilis√© dans le reste du code.
Cela permet au serpent de se d√©placer automatiquement toutes les secondes, tout en permettant √† l'utilisateur de contr√¥ler la direction et de voir les mises √† jour du jeu sans interruption.

### Conclusion

Il reste √©norm√©ment de choses qui ne vont pas dans le snake Julia (et a fortiori dans le Snake R‚Ä¶) :

‚Üí Le serpent n‚Äôavance pas de lui m√™me malgr√© tout nos essais
‚Üí Le d√©placement est saccad√©, parfois le corps saute une case (mais pas toujours!) m√™me si je soup√ßonne la fonction new_head d‚Äôen √™tre √† l‚Äôorigine sans avoir trouv√© pourquoi...(au moins le serpent tourne!)
‚Üí La nourriture ne r√©appara√Æt pas, une fois la pomme mang√©e le jeu s‚Äôarr√™te (√† vrai dire nous n‚Äôavons pas eu le temps de nous int√©resser √† cette probl√©matique)

Ce snake √† √©tait fait sur un coup de t√™te tout √† la fin du projet. Ce qu‚Äôil faut retenir c‚Äôest qu‚Äôil nous a bien compliqu√© la vie, nous a beaucoup appris sur les capacit√©s et les possibilit√©s qu‚Äôoffre Julia.

Il √©tait int√©ressant de tester avec R, mais au bout de quelques heures nous avions compris que R ne nous permettrait pas (en tout cas pas rapidement) d‚Äôarriver √† un r√©sultat concluant.

Julia est un langage de programmation exceptionnel, en particulier lorsqu'il s'agit de cr√©er des mini-jeux et de travailler sur des projets n√©cessitant √† la fois des performances et une simplicit√© de d√©veloppement.

L'un des plus grands avantages de Julia √©tait la rapidit√© d‚Äôex√©cution. La syntaxe de Julia ressemblait dans un premier temps √† Python, claire et intuitive ce qui le rend accessible aux d√©butants tout en √©tant puissante pour les d√©veloppeurs.

Le snake montre bien comment Julia peut permettre de structurer un jeu de mani√®re concise et lisible, tout en g√©rant facilement des fonctionnalit√©s telles que les entr√©es utilisateur, l'affichage, et la gestion de la logique du jeu. R n‚Äô√©tait pas mauvais sur ce point mais le c√¥t√© intuitif de Julia facilitait cet aspect.

En nous renseignant on a vu que m√™me pour un mini-jeu, Julia permet de tirer parti des fonctionnalit√©s de parall√©lisme et de concurrence. Si notre jeu √©tait amen√© √† devenir plus complexe (par exemple, si on ajoutes des calculs physiques ou des IA), Julia permettrait de parall√©liser les t√¢ches sans effort suppl√©mentaire. Cela peut rendre ton jeu plus fluide et r√©actif, m√™me sur des machines avec plusieurs c≈ìurs de processeur.

Viennent ensuite tous les aspects de Julia que nous n‚Äôavons pas abord√©s. Dans le snake dans le but de comparer R et Julia nous n‚Äôavons pas chercher √† utiliser les capacit√©s de Julia pour les graphiques (m√™me si on en utiliser pour le machine learning). Toujours avec le snake nous n‚Äôavons pas non plus cherch√© √† utiliser les capacit√©s de Julia permettant d'interagir facilement avec du code C ou Python, offrant une flexibilit√© suppl√©mentaire en cas de besoin.

Cependant !
Nous avons fait un petit bonus. Notre cher professeur nous a tant parl√© du ¬´ multiple dispatching ¬ª, a.k.a la plus grande arme de Julia. Alors pour apprivoiser cette nouvelle notion, nous nous sommes renseign√©es et avons essay√© de faire ce m√™me code Snake en le rendant propice au multiple dispatching. (Le code fait exactement la m√™me chose ceci dit).

## Snake Game avec du multiple dispatching

Dans le code pr√©c√©dent, il n'y a pas de multiple dispatching en tant que tel, mais apr√®s renseignement, il est possible d‚Äôen ajouter pour exploiter cette fonctionnalit√© puissante de Julia, qui permet d'avoir plusieurs m√©thodes pour une m√™me fonction, adapt√©es √† diff√©rents types d'arguments. Le multiple dispatch permet de d√©finir diff√©rentes impl√©mentations d'une fonction selon les types des arguments pass√©s.
Les premi√®res id√©es simples de multiple dispatch √† int√©grer dans le code auxquelles on a pens√© sont:

Ce que j'ai modifi√© pour utiliser le multiple dispatch :
1.	Types diff√©rents pour les serpents :
‚Ä¢	J'ai cr√©√© un nouveau type LongSnake, qui h√©rite de AbstractSnake, et qui contient une propri√©t√© speed pour modifier la vitesse de d√©placement.

‚Ä¢	Vous pouvez ajouter plus de types, comme des serpents qui grandissent plus rapidement ou qui ont des comportements diff√©rents.

2.	move_snake est dispatch√© selon le type de serpent :
‚Ä¢	La fonction move_snake se comporte diff√©remment selon qu'il s'agit d'un Snake ou d'un LongSnake. Cela permet d'avoir un comportement diff√©rent, par exemple en fonction de la vitesse dans le cas d'un LongSnake.

3.	Le game_loop utilise un LongSnake :
‚Ä¢	Le jeu utilise d√©sormais LongSnake par d√©faut pour montrer comment cela pourrait fonctionner avec un serpent ayant des comportements distincts.
Cette approche permet de facilement √©tendre le jeu √† diff√©rents types de serpents, chacun ayant ses propres caract√©ristiques et comportements. On pourrait imaginer plusieurs mode de jeu, plus ou moins classique. Avec plus de temps et un code plus complexe on aurait pu laisser le choix au joueur sur la taille et les sp√©cificit√© du serpent. On aurait pu ajout√© des types de nourritures diff√©rentes et dont le multiple dispaching aurait grandement facilit√© le codage. Cela offre une base pour ajouter davantage de fonctionnalit√©s ou types de serpents sans modifier profond√©ment la structure du code.

PROBLEME ET CONCLUSION: les directions ne fonctionnent plus et le corps du serpent s‚Äôagrandit sans avoir mang√©. Ce probl√®me n‚Äôaura jamais √©t√© r√©solu et nous n‚Äôavons malheuresement plus le temps. On est en revanche contente d‚Äôavoir tout de m√™me fait ce code avec du mulitple dispaching m√™me si on ne peut pas voir son impacte directement (visuellement) lorsque le jeu est lanc√©. Int√©rieurement, nous avons compris comment le multiple dispaching fonctionnait.

## Cr√©ation de Packages

Un des derni√®res √©tapes de notre projet a √©t√© de cr√©er les packages qui regroupe toutes nos fonctions cr√©√©es pour les rendre facilement r√©utilisables. Nous avons cr√©√© un package R et un autre Julia. Ce qui a √©t√© tr√®s compliqu√© au d√©but surtout pour le package Julia.

Pour Julia j‚Äôai commenc√© par suivre un tutoriel trouv√© en ligne, qui expliquait comment cr√©er un package manuellement. Ce tuto montrait comment structurer correctement le package en d√©finissant un module portant le nom que l‚Äôon voulait pour le package. Il indiquait √©galement la hi√©rarchie n√©cessaire avec des dossiers comme src/, les fichier Project.toml‚Ä¶ J‚Äôai donc compris la structure g√©n√©rale, mais la configuration √©tait trop compliqu√©e. Heureusement nous avons eu un magnifique tuto cr√©er par Mr Remy qui nous a expliqu√© en d√©tails comment cr√©er un package Julia de mani√®re standard, ce qui m‚Äôa permis de corriger ce que j‚Äôavais fats pr√©c√©demment, maintenant on est des expertes dans la cr√©ation de package.

Un des probl√®mes que j‚Äôai rencontr√© dans la cr√©ation de mon package, concern√© le d√©p√¥t sur GitHub. Lors de la cr√©ation de mon repository, je cochais syst√©matiquement la case ¬´ Add a README file ¬ª qui provoquait des conflits avec les fichiers que j‚Äôessayais de push. J‚Äôai donc du recr√©er plusieurs fois un package avant de comprendre d‚Äôo√π venait l‚Äôerreur. Une autre erreur qui apparait, tous mes push depuis la cr√©ation du package ont des erreurs mais toutes les mises a jour que je fais sont bien dans le GitHub alors je ne comprends pas. Finalement j‚Äôai r√©ussi √† tout configurer correctement et j‚Äôai nomm√© mon package ProjetRJulia.jl qui est d√©sormais fonctionnel et accessible.

Le plus grand d√©fi que j‚Äôai rencontr√© lors de la cr√©ation de mon package a √©t√© la mise en place et le processus de push sur GitHub. A chaque tentative de push, sans exception (je ne mens pas) j‚Äôai rencontr√© des √©checs. Il y avait toujours un probl√®me, ce qui m‚Äôa demand√© √©norm√©ment de temps pour tout r√©soudre.

Au d√©but le probl√®me principal venait des packages utilis√©s dans mon code. Ils n‚Äô√©taient pas correctement int√©gr√©s dans mon package ProjetRJulia.jl. Ce qui g√©n√©rait des erreurs lors de l‚Äôex√©cution. Pour r√©soudre √ßa, j‚Äôai d√ª m‚Äôassurer que tous les packages n√©cessaires √©taient bien charg√©s dans le fichier Project.toml avant de pouvoir pousser les premiers commits.

Ensuite j‚Äôai rencontr√© des probl√®mes de version. Mon package √©tait d√©fini avec la version 1.10 mais certains des autres packages, comme Pkg, √©taient sur la version 1.11, qui correspond √† la derni√®re version de Julia. Ce qui a caus√© des conflits de version lors du push. De m√™me, les packages ScikitLearn cherchait √† installer des versions de packages plus anciennes que celles d√©j√† pr√©sentes sur mon syst√®me, ce qui a provoqu√© des erreurs, encore. Pour r√©soudre ce probl√®me j‚Äôai du supprimer tous les packages et r√©installer ScikitLearn en premier, puis ajouter les autres packages par la suite dans le bon ordre.

Le dernier probl√®me √©tait li√© √† la gestion de la base de donn√©es. Sur GitHub, le chemin pour acc√©der a mon fichier de donn√©es n‚Äô√©tait pas valide, car il faisait r√©f√©rence au chemin local de mon ordinateur. Pour contourner ce probl√®me, j‚Äôai cr√©√© une fonction permettant de charger dynamiquement le dataset, de mani√®re que le package puisse √™tre utilis√© par n‚Äôimporte qui, peu importe ou il est install√©. Cette fonction ne d√©pend d√©sormais que du r√©pertoire sp√©cifi√© dans le package, ce qui rend l‚Äôutilisation du package plus flexible et compatible sur diff√©rentes machines.

En r√©sume, la configuration correcte de l‚Äôenvironnement, la gestion des versions des packages et l‚Äôadaptation du code pour √©viter les d√©pendances sp√©cifiques √† mon syst√®me local ont √©t√© des √©tapes cl√©s pour r√©soudre ces probl√®mes et r√©ussir √† mettre en place et pousser sur GitHub.

Pour le package R, nous avions d√©velopp√© plusieurs scripts R, notamment pour l‚Äôapplication Shiny et pour l‚Äôalgorithme de machine Learning et il fallait les placer dans un package. J‚Äôai suivi un autre tutoriel en ligne qui expliquait √©tape par √©tape comment cr√©er un package R en utilisant les outils de base. Apr√®s avoir v√©rifi√© que tout fonctionnait correctement, j‚Äôai √©galement d√©pos√© ce package sur GitHub afin de le rendre accessible et r√©utilisable par d‚Äôautres.

En conclusion cette √©tape de cr√©ation de package a √©t√© une exp√©rience enrichissante, m√™me si ca a √©t√© compliqu√©. Elle nous a permis de mieux comprendre les bonnes pratiques de structuration de projet en Julia et en R et  l‚Äôutilit√©s de l‚Äôint√©gration avec GitHub.


## Bilan du projet

Finalement ce projet est all√© dans tout les sens ! Il est bien loin le temps o√π nous voulions pr√©dire les m√©dailles aux prochains JO. Nous ne nous rendions pas compte de la tache qui nous attendait‚Ä¶

Lorsqu‚Äôon s‚Äôest aper√ßue que le projet ne menait nul part il a fallut qu‚Äôon r√©agisse vite. Nous ne voulions pas recommencer un brain storming et tout ce qui s‚Äôen suit. Nous voulions r√©utiliser ce que nous avions d√©j√† pour continuer. Finalement notre projet s‚Äôest transform√© en comparaison R/Julia sur tout les plans.

Il est maintenant temps de faire un r√©capitulatif :

R√©sum√© des Diff√©rences Pour le d√©veloppement du jeu:

1.	Langage et Syntaxe: Le code en R est bas√© sur des structures comme les listes et les data.frame, tandis qu'en Julia, des struct et des Vector sont utilis√©s pour des performances et une gestion de m√©moire plus optimis√©es.

2.	Affichage: Les deux utilisent la console pour afficher la grille, mais en R, l'affichage est plus simple avec cat, tandis qu'en Julia, des s√©quences d'√©chappement ANSI sont utilis√©es pour effacer l'√©cran.

3.	Gestion de la Direction: En R, la direction est un vecteur simple (ex. c(1, 0)), tandis qu'en Julia, un dictionnaire est utilis√© pour associer des caract√®res √† des vecteurs de direction.

4.	Entr√©es Utilisateur: En R, readline est utilis√© pour obtenir l'entr√©e utilisateur, et en Julia, readline lit l'entr√©e sans blocage, mais get_input est utilis√© de mani√®re non-bloquante.

5.	Performance: En raison des types de donn√©es plus avanc√©s et de la gestion plus fine de la m√©moire en Julia, l'impl√©mentation peut potentiellement √™tre plus performante pour des jeux plus complexes ou plus grands.

Dans l'ensemble, les deux impl√©mentations suivent une structure similaire mais utilisent des approches diff√©rentes en fonction des capacit√©s et des idiomes de chaque langage.

Le choix entre les deux impl√©mentations d√©pend de plusieurs crit√®res li√©s au d√©veloppement, tels que la lisibilit√©, la performance, la flexibilit√© du code, ainsi que l'apprentissage des concepts li√©s aux langages utilis√©s. Voici nos avis plus d√©taill√©s de chaque langage et de leur int√©r√™t d'un point de vue d√©veloppement.

1. Lisibilit√© et Simplicit√©
‚Ä¢	R:
‚Ä¢	Avantages:
‚Ä¢	Syntaxe simple et directe : R est un langage relativement simple √† apprendre, surtout pour ceux qui sont habitu√©s √† des langages orient√©s statistique ou scientifique. Les op√©rations sur des vecteurs et des listes sont directes.
‚Ä¢	Lisibilit√© imm√©diate : Le code est assez lin√©aire, avec des fonctions simples pour dessiner la grille, d√©placer le serpent, etc. Cela peut √™tre plus facile √† comprendre pour un d√©butant.
‚Ä¢	Inconv√©nients :
‚Ä¢	Le code utilise des variables globales et des manipulations de listes, ce qui peut rendre le suivi de l'√©tat du jeu moins explicite, surtout si on complexifie l'application.
‚Ä¢	L'utilisation de cat et de readline pour g√©rer l'affichage et les entr√©es clavier peut √™tre un peu moins pratique pour des applications plus complexes, et cela peut limiter la flexibilit√© du jeu (par exemple, dans des interfaces graphiques).

‚Ä¢	Julia:
‚Ä¢	Avantages:
‚Ä¢	Syntaxe claire et moderne : Julia utilise une syntaxe propre et bien structur√©e. Le code utilise des struct pour le serpent et un Dict pour la gestion des directions, ce qui est plus modulable et extensible.
‚Ä¢	Meilleure gestion des types : L'utilisation de types comme Vector{Tuple{Int, Int}} pour repr√©senter les coordonn√©es du serpent rend les donn√©es plus structur√©es et clairement typ√©es. Cela aide √† √©viter des erreurs li√©es aux types de donn√©es et rend le code plus pr√©visible.
‚Ä¢	Inconv√©nients :
‚Ä¢	La syntaxe de Julia peut √™tre un peu plus complexe pour les d√©butants par rapport √† R, notamment avec l'utilisation de struct et des types g√©n√©riques. Cela peut n√©cessiter un peu plus d'efforts pour bien comprendre l'organisation du code.
‚Ä¢	L'affichage de la grille en utilisant des s√©quences d'√©chappement ANSI (pour effacer l'√©cran) peut rendre le code moins portable ou moins clair, notamment pour des d√©butants.


2. Performance et Scalabilit√©:
‚Ä¢	R:
‚Ä¢	Avantages :
‚Ä¢	Rapidit√© pour les petites tailles de grilles : Le code en R fonctionnera bien pour des jeux de petite taille (par exemple, une grille de 10x10). R √©tant un langage tr√®s performant pour les calculs sur des vecteurs et des matrices, il peut √™tre suffisant pour des jeux simples ou des prototypes rapides.
‚Ä¢	Inconv√©nients :
‚Ä¢	Manque de gestion m√©moire optimis√©e : R n'est pas con√ßu pour les applications en temps r√©el sans interactions . La gestion des objets comme des listes ou des data.frame dans un jeu deviendrait rapidement trop co√ªteuse √† mesure que le jeu se complexifie (par exemple, avec une grille plus grande ou plus de segments de serpent).
‚Ä¢	Pas de gestion avanc√©e des entr√©es/sorties en temps r√©el : Le code d√©pend des fonctions comme readline, qui sont bloquantes et peuvent nuire √† l'interactivit√© en temps r√©el dans un jeu plus complexe.


‚Ä¢	Julia:
‚Ä¢	Avantages :
‚Ä¢	Haute performance : Julia est un langage con√ßu pour la performance, notamment avec des op√©rations sur des tableaux (comme ceux utilis√©s pour la grille et le serpent). Sa gestion de la m√©moire est plus optimis√©e que celle de R, et il est con√ßu pour les calculs num√©riques rapides, ce qui en fait un bon choix pour des jeux plus complexes ou qui n√©cessitent une mise √† jour rapide.
‚Ä¢	Parall√©lisme et extensibilit√© : Julia permet une mise en ≈ìuvre plus facile de fonctionnalit√©s complexes et des am√©liorations de performance comme le parall√©lisme et les calculs vectoris√©s. Cela pourrait √™tre utile si on d√©cidait d'√©tendre le jeu (par exemple, augmenter la taille de la grille ou ajouter de nouvelles fonctionnalit√©s).
‚Ä¢	Inconv√©nients :
‚Ä¢	Surcouche de performance pour des jeux simples : Si le jeu reste simple (petite grille, peu d'√©l√©ments), la performance sup√©rieure de Julia ne sera pas pleinement exploit√©e, et la complexit√© du langage pourrait √™tre superflue.


3. Utilisation des Capacit√©s Avanc√©es du Langage
‚Ä¢	R:
‚Ä¢	Avantages :
‚Ä¢	R est principalement utilis√© pour des analyses statistiques et des traitements de donn√©es. Si votre objectif est de cr√©er un jeu rapide en tant qu'exercice ou une simulation simple, R est suffisant et assez rapide pour des jeux de petite taille(mais avec des interactions).
‚Ä¢	Inconv√©nients :
‚Ä¢	R n'est pas con√ßu pour des applications interactives ou en temps r√©el. Les biblioth√®ques de gestion des √©v√©nements clavier et de l'affichage sont limit√©es par rapport √† d'autres langages comme Julia ou Python.


‚Ä¢	Julia:
‚Ä¢	Avantages :
‚Ä¢	Julia est con√ßu pour des applications de haute performance et permet une meilleure utilisation des ressources, surtout pour des jeux en temps r√©el (m√™me si nous n‚Äôavons pas r√©ussis, nous avons vu qu‚Äôil existait des semblant de solutions l√† o√π nous n‚Äôavons rien trouv√© pour R). Il permet √©galement une int√©gration facile avec des biblioth√®ques de calcul scientifique, ce qui peut √™tre utile pour des extensions futures (par exemple, des simulations physiques ou des calculs complexes dans le jeu).
‚Ä¢	Inconv√©nients :
‚Ä¢	Comme Julia est encore relativement jeune et moins utilis√© pour des applications comme les jeux vid√©o, certaines biblioth√®ques de gestion graphique ou d'interface utilisateur ne sont pas aussi matures que celles disponibles en R, Python ou C#.

Conclusion : Lequel est le plus int√©ressant ?

‚Ä¢	Si on recherche la simplicit√© et un d√©veloppement rapide : Le code en R est plus facile √† comprendre et √† mettre en place pour des projets simples. C'est un bon choix pour un d√©butant ou pour un prototypage rapide.

‚Ä¢	Si vous visez la performance, la flexibilit√© et l'extensibilit√© : Le code en Julia est plus adapt√© pour des projets √† long terme et pour des jeux plus complexes. Il offre une meilleure gestion des performances et une architecture plus modulaire, permettant une √©volution plus facile du jeu.

‚Ä¢	Pour un jeu simple et rapide : R peut suffire. Mais pour un jeu qui pourrait √©voluer en complexit√© ou qui pourrait √™tre utilis√© comme base pour des projets plus ambitieux, Julia est un choix plus robuste et flexible.

En r√©sum√©, si le projet est destin√© √† √©voluer avec des fonctionnalit√©s suppl√©mentaires ou n√©cessite une meilleure performance, Julia est le meilleur choix. Si le projet est simple et que vous cherchez √† apprendre rapidement ou √† prototyper un jeu simple, R est suffisant mais au m√™me titre que Julia.





