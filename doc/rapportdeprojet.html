<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Emma Roume et Jade Bordet">

<title>Rapport de Projet R et Julia</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="rapportdeprojet_files/libs/clipboard/clipboard.min.js"></script>
<script src="rapportdeprojet_files/libs/quarto-html/quarto.js"></script>
<script src="rapportdeprojet_files/libs/quarto-html/popper.min.js"></script>
<script src="rapportdeprojet_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="rapportdeprojet_files/libs/quarto-html/anchor.min.js"></script>
<link href="rapportdeprojet_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="rapportdeprojet_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="rapportdeprojet_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="rapportdeprojet_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="rapportdeprojet_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Rapport de Projet R et Julia</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Emma Roume et Jade Bordet </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">Invalid Date</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Dans le cadre de notre Master 1 en Statistique et Science des DonnÃ©es, nous avons rÃ©alisÃ© un projet dans le cadre des UE Logiciels SpÃ©cialisÃ©s (parties sur R et Julia) et lâ€™UE Outils de prÃ©sentation et de recherche reproductible. Ce projet avait pour principal objectif de consolider et dÃ©velopper nos compÃ©tences en programmation avec R mais aussi de dÃ©couvrir le logiciel Julia. Il fallait faire en deux modes, en mode utilisateur : Environnement de travail ; Notion de package (installation, utilisation); Introduction des natures et structures R de base; Extraction de donnÃ©es avec application sur donnÃ©es rÃ©elles. Mais aussi, en mode dÃ©veloppeur : Programmation fonctionnelle ; CrÃ©ation de package; Programmation orientÃ©e objet (S3); Introduction au package RCpp pour booster les exÃ©cutions des codes R.</p>
<p>Nous disposions dâ€™une totale libertÃ© dans le choix de sujet de notre projet, une approche qui visait Ã  stimuler notre engagement et Ã  encourager notre crÃ©ativitÃ© (merci Remy).</p>
<p>Ce rapport retrace notre parcours tout au long de ce projet, une aventure pleine de dÃ©fi et ou on a failli sâ€™arracher les cheveux Ã  de multiple reprise. La mise en place a nÃ©cessitÃ© une bonne dose dâ€™organisation et de persÃ©vÃ©rance.</p>
<p>Ce document sert Ã©galement de synthÃ¨se, il va nous permettre de revenir sur les difficultÃ©s, les points forts et faibles de notre projet mais aussi de prÃ©senter la stratÃ©gie mise en place.</p>
</section>
<section id="dÃ©but-de-notre-projet" class="level2">
<h2 class="anchored" data-anchor-id="dÃ©but-de-notre-projet">DÃ©but de notre projet</h2>
<p>Nous avons dâ€™abord cherchÃ© un sujet qui pouvait nous plaire Ã  toutes les deux. AprÃ¨s rÃ©flexion on a dÃ©cidÃ© de partir sur le sport en gÃ©nÃ©ral, Jade Ã©tant trÃ¨s sportive et moi qui adore regarder le sport Ã  la tÃ©lÃ© ! La gymnastique Ã©tant un sport que nous apprÃ©cions toutes les deux nous sommes donc parties sur cela. En discutant dâ€™avantage une idÃ©e nous est venue : est -il possible de prÃ©dire les prochaines mÃ©dailles olympiques aux JO 2028 en gymnastique ?</p>
<p>Un mÃ©lange de ce que lâ€™on aime toutes les deux et un dÃ©fi sympa Ã  rÃ©aliser (irrÃ©alisable finalementâ€¦)</p>
<p>Qui dis prÃ©diction dis Machine Learning notre projet serait donc de crÃ©er un algorithme de machine Learning dans le but de prÃ©dire les prochaines mÃ©dailles au JO.</p>
<p>Au dÃ©but de notre projet on a vite rÃ©alisÃ© quâ€™il Ã©tait essentiel pour nous de trouver une base de donnÃ©es adaptÃ©e, contenant toutes les variables nÃ©cessaires pour rÃ©aliser notre projet et faire une classification. Notre premiÃ¨re idÃ©e Ã©tait de crÃ©er notre propre base de donnÃ©es. Ce qui aurait trÃ¨s intÃ©ressant pour avoir un contrÃ´le sur les donnÃ©es dont on avait besoin, mais on sâ€™est trÃ¨s vite rendu compte que cette tÃ¢che serait trÃ¨s compliquÃ©e. CrÃ©er une base de donnÃ©es avec toutes les variables dont nous avons besoin aurait Ã©tÃ© une perte de temps considÃ©rable. De plus ce travail nâ€™est pas adaptÃ© au cours dans le quelle nous somme mais plus Ã  un cours de base de donnÃ©es. Ce travail nous aurait pris plus de temps que de crÃ©er le code, donc on a abandonnÃ© lâ€™idÃ©e.</p>
<p>Pour gagner en efficacitÃ© sur ce projet, on a alors commencÃ© nos recherches pour trouver une base de donnÃ©es dÃ©jÃ  existante. Nous avons explorÃ© plusieurs sites jusquâ€™Ã  ce que nous tombions sur une base de donnÃ©es Kaggle qui rÃ©pondait parfaitement Ã  nos besoins. Ce jeu de donnÃ©es contenait toutes les variables nÃ©cessaires pour construire notre modÃ¨le de classification. Ce qui nous a permis de nous concentrer sur la modÃ©lisation, et lâ€™implÃ©mentation dâ€™algorithmes.</p>
<p>Une fois la base de donnÃ©es choisie nous avons dÃ©cidÃ© dâ€™utiliser Julia pour crÃ©er notre algorithme de machine Learning. Julia Ã©tant un langage que nous connaissions peu, mais il nous lâ€™a Ã©tÃ© vendu comme super performant alors quoi de mieux que Julia pour implÃ©menter cet algorithme ! Nous avons vu ce projet comme une opportunitÃ© de nous familiariser avec Julia en appliquant des concepts de machine Learning, ce qui nous a permis dâ€™Ã©largir nos compÃ©tences et de dÃ©couvrir tous ses atouts.</p>
<p>Pour le choix de lâ€™algorithme, nous avons optÃ© pour Random Forest. Cet algorithme est particuliÃ¨rement rÃ©putÃ© pour sa robustesse et ses performances dans les taches de classification. Il fonctionne en combinant les prÃ©dictions de plusieurs arbres indÃ©pendant chacun Ã©tant construit sur un sous-Ã©chantillon alÃ©atoire des donnÃ©es. Câ€™est cette robustesse qui a motivÃ© notre choix.</p>
<p>Pour dÃ©buter a coder, la premiÃ¨re Ã©tape a Ã©tÃ© de nettoyer la base de donnÃ©es. Cela mâ€™a pris pas mal de temps car jâ€™ai voulu effectuer ce nettoyage Ã  la fois sur R et sur Julia, afin de comparer et de mâ€™exercer sur les deux langages. Jâ€™ai donc commencÃ© par nettoyer une premiÃ¨re base de donnÃ©es, mais jâ€™ai ensuite dÃ©couvert quâ€™elle ne contenait des rÃ©sultats que jusquâ€™en 2016, ce qui ne correspondait pas du tout Ã  ce que je voulais.</p>
<p>Le nettoyage de la base de donnÃ©es a impliquÃ© plusieurs Ã©tapes importantes. La base de donnÃ©es dâ€™origines Ã©tait trÃ¨s large et contenait des donnÃ©es pour tous les sports des Jeux olympiques. Jâ€™ai donc commencÃ© par filtrer les donnÃ©es pour ne conserver uniquement les lignes ou la gymnastique apparaissait comme discipline. Ensuite jâ€™ai restreint la pÃ©riode dâ€™analyse aux annÃ©es 2008 et 2020 afin de pouvoir entrainer lâ€™algorithme.</p>
<p>Une autre Ã©tape assez importante a Ã©tÃ© le traitement de la variable mÃ©daille, comme cette variable contenait des valeurs manquantes, cela sâ€™expliquait par le fait que la personne sur la ligne nâ€™avait pas gagnÃ© de mÃ©daille, jâ€™ai choisi de remplacer par une nouvelle catÃ©gorie intitulÃ©e Â« no medals Â» pour bien signifier que le participant nâ€™avait rien remportÃ©.</p>
<p>Par la suite jâ€™ai transformÃ© les catÃ©gories textuelles gold, silver, bronze et no medals en valeur numÃ©rique (1, 2, 3 et 0 respectivement). Cette conversion est essentielle, car lâ€™algorithme Random Forest, travaille avec des donnÃ©es numÃ©riques et non textuelles. En transformant les catÃ©gories en Ã©tiquettes numÃ©riques, jâ€™ai rendu la variable exploitable pour lâ€™entrainement de notre modÃ¨le.</p>
<p>Enfin, jâ€™ai Ã©galement modifiÃ© la variable event, qui contenait les noms des diffÃ©rents agrÃ©es de gymnastique. Ces noms Ã©taient souvent trop longs et en anglais, ce qui nâ€™Ã©tait pas trÃ¨s pratique pour travailler et comprendre les donnÃ©es. Jâ€™ai donc traduit les noms des disciplines en franÃ§ais et je les ai remplacÃ©s par des termes correspondant aux agrÃ©es de gymnastique comme sol, poutreâ€¦ Cette Ã©tape avait pour but de rendre les donnÃ©es plus comprÃ©hensible et accessible pour lâ€™utilisation.</p>
<p>Ce nettoyage a Ã©tÃ© donc une Ã©tape essentielle pour prÃ©parer les donnÃ©es avant dâ€™appliquer lâ€™algorithme de machine Learning. Il a permis de transformer une base de donnÃ©es pour la rendre prÃªte Ã  lâ€™emploi.</p>
<p>Pour chaque Ã©tape du projet, on a dÃ©cidÃ© de crÃ©er des fonctions spÃ©cifiques. Dâ€™abord jâ€™ai Ã©crit une fonction pour nettoyer la base de donnÃ©es, puis une autre pour entrainer le modÃ¨le avec lâ€™algorithme Random Forest. Câ€™est Ã  ce moment la que je me suis retrouvÃ© face Ã  une erreur que jâ€™ai mis Ã©normÃ©ment de temps Ã  rÃ©soudre.</p>
<p>Mon problÃ¨me Ã©tait que je nâ€™arrivais pas Ã  trouver une fonction qui me permettait de convertir toutes mes variables catÃ©gorielles textuelles en variables numÃ©riques, tout en Ã©vitant lâ€™implication dâ€™une relation dâ€™ordre entre les catÃ©gories. Par exemple, lâ€™algorithme pourrait interprÃ©ter que le fait de mettre femelle=1 et male =2, signifierait 1&lt;2, mais ce nâ€™est pas le cas.</p>
<p>Câ€™est la quâ€™intervient la fonction One-Hot-Encoding. Cette fonction permet de convertir des catÃ©gories textuelles en plusieurs colonnes binaires indÃ©pendantes. Par exemple pour la variable sex, elle va crÃ©er deux colonnes distinctes : sex_male, sex_female. Pour caque ligne de la base de donnÃ©es la colonne sex_male prendra 1 si la personne est un homme et 0 sinon et de mÃªme pour la colonne sex_female. Cette transformation supprime toute notion dâ€™ordre implicite et est beaucoup mieux adaptÃ© pour lâ€™algorithme Random Forest, qui fonctionne avec des valeurs numÃ©riques.</p>
<p>Malheureusement pour moi la fonction de One-Hot-Encoding dÃ©jÃ  implÃ©mentÃ©e sur Julia ne fonctionnait pas correctement dans mon code. Jâ€™ai donc dÃ©cider de crÃ©er ma propre fonction en mâ€™inspirant de fonction trouvÃ©e sur internet. AprÃ¨s quelques essais et ajustement, jâ€™ai rÃ©ussi a obtenir une fonction opÃ©rationnelle.</p>
<p>La derniÃ¨re fonction que jâ€™ai crÃ©Ã©e permet dâ€™Ã©valuer le modÃ¨le aprÃ¨s lâ€™entrainement, en calculant plusieurs scores dâ€™Ã©valuation comme lâ€™accuracy, la prÃ©cision et la matrice de confusion. Cela mâ€™a permis de mieux comprendre les performances du modÃ¨le, qui nâ€™Ã©tait pas trÃ¨s bonnes ğŸ˜Š</p>
<p>Enfin lâ€™une des derniÃ¨res Ã©tapes de mon code consistait Ã  afficher les rÃ©sultats sous la forme suivante : je voulais lister, pour chaque catÃ©gorie, le nom des athlÃ¨tes ainsi que la mÃ©daille quâ€™ils avaient remportÃ©e.</p>
<p>En ce qui concerne les rÃ©sultats, la bonne nouvelle est que jâ€™arrive effectivement Ã  obtenir des prÃ©dictions et Ã  faire tourner mon code, mais malheureusement, elles ne sont pas du tout satisfaisantes. Mon accuracy est trÃ¨s faible, ce qui signifie que le modÃ¨les ne parvient pas Ã  faire de bonnes prÃ©dictions. Le principal problÃ¨me est que je reÃ§ois des rÃ©sultats dupliquÃ©s. Par exemple, pour la catÃ©gorie Â« barre asymÃ©trique Â», le modÃ¨le prÃ©dit deux voir trois personnes remportant la mÃ©daille dâ€™or, ce qui est Ã©videmment impossible. Et parfois mÃªme elle ne trouvait personne remportant la mÃ©daille dâ€™or, il y avait des trous.</p>
<p>Je pense que lâ€™algorithme a appris que plusieurs personnes peuvent avoir la mÃªme proba de gagner une mÃ©daille, sans comprendre quâ€™il ne peut y avoir quâ€™un seul gagnant par mÃ©daille dans chaque catÃ©gorie. Ce problÃ¨me peut aussi venir du fait que ma base de donnes est relativement petite, aprÃ¨s avoir Ã©lÃ©mine les lignes inutiles, je nâ€™avais plus quâ€™une centaine de lignes, ce qui nâ€™est pas du tout satisfaisant pour entrainer correctement un modÃ¨le de ce genre. Je pense que câ€™est ce qui a fait que parfois il ne me donnait personne pour la mÃ©daille dâ€™or surement que les lignes avaient Ã©tÃ© supprimÃ©es.</p>
<p>Voici ce que jâ€™obtiens:</p>
<pre class="{julia}"><code>using ProjetRJulia
using DataFrames
using MLJ

#On prÃ©pare la base de donnÃ©e et on charge
filtered_data = ProjetRJulia.load_data2()

#Je veux dans mon rÃ©sultat, le nom, la mÃ©daille gagnÃ©e et dans quelle event 
prediction = DataFrame(Name = filtered_data.Name[partition(eachindex(filtered_data.Medal), 0.7)[2]], pred_Medal = y_pred, Event = filtered_data.Event[partition(eachindex(filtered_data.Medal), 0.7)[2]])

resultat_par_evnmt = groupby(prediction, :Event)
</code></pre>
<p>Au final, jâ€™ai compris que ce projet dans cette forme la, nâ€™Ã©tait pas totalement rÃ©alisable, Le manque de donnÃ©es suffisantes et la difficultÃ© Ã  faire en sorte que lâ€™algorithme apprenne correctement ont limitÃ© la performance du modÃ¨le. Ca nous a permis de prendre conscience de lâ€™importance de la qualitÃ© et de la taille des donnÃ©es dans la crÃ©ation dâ€™un algorithme de machine Learning.</p>
<p>Histoire de quand mÃªme avancer dans notre apprentissage du machine learning, de comprendre son fonctionnement et rendre un code assez potable, nous avons rÃ©flÃ©chie a une alternative. Nous nous sommes mis dâ€™accord sur lâ€™idÃ©e de rÃ©aliser deux algorithmes de Machine Learning : un pour la prÃ©diction des mÃ©dailles (mÃªmes si les rÃ©sultats ne sont pas bons) et un autre basÃ© sur une autre base de donnÃ©es plus grande et plus fiable.</p>
<p>Nous avons donc dÃ©cider de crÃ©er un autre algorithme sur une autre base de donnÃ©es, beaucoup plus grande cette fois. Pour ce deuxiÃ¨me algorithme, nous avons choisi de travailler avec une base de donnÃ©es sur le cancer du sein. Le but ici Ã©tait dâ€™obtenir de bons rÃ©sultats en termes dâ€™accuracy, de prÃ©cision et dâ€™autres mÃ©triques dâ€™Ã©valuations. Jâ€™ai donc nettoyÃ© cette base de donnÃ©es, puis entrainÃ© le modÃ¨le de Random Forest et Ã©valuÃ© la performance du modÃ¨le, exactement de la mÃªme maniÃ¨re que pour la prÃ©diction de mÃ©daille et toujours sur Julia.</p>
<p>AprÃ¨s avoir obtenu les rÃ©sultats, nous nous sommes dit Â« Pourquoi pas comparer les performances de R et Julia en machine learning ? Â». Jâ€™ai donc rÃ©Ã©crit un algorithme similaire en R et en utilisant le package caret et lâ€™algorithme Random Forest, pour comparer les rÃ©sultats avec ceux gÃ©nÃ©rÃ©s par Julia. Comme on le pressentais, les rÃ©sultats Ã©taient meilleurs avec Julia. En effet, pour les mÃªmes hyperparamÃ¨tres et les mÃªmes donnÃ©es dâ€™entrÃ©e, les performances du modÃ¨le en Julia Ã©taient meilleures en termes dâ€™accuracy, de prÃ©cision et des autres mÃ©triques dâ€™Ã©valuation. Voici les performances en Julia:</p>
<pre class="{julia}"><code>using ProjetRJulia
accuracy, cm, recall_score, f1_score = evaluate_model(y_test, y_pred)</code></pre>
<p>Pour moi, la principale raison de cette diffÃ©rence rÃ©side dans la nature des langages. R est un langage interprÃ©tÃ©, ce qui signifie que chaque ligne de code est traduite et exÃ©cutÃ©e Ã  la volÃ©e par lâ€™interprÃ©teur. Ã‡a peut entrainer des ralentissements, surtout quand il sâ€™agit de tache intensive comme la crÃ©ation des arbres de dÃ©cision. Julia lui est un langage compilÃ© Ã  la volÃ©e, ce qui lui permet dâ€™exÃ©cuter des codes plus rapidement et plus efficacement. Cette diffÃ©rence de fonctionnement a donc un impact direct sur les performances, particuliÃ¨rement pour des algorithmes de machine Learning qui nÃ©cessitent des calculs rÃ©pÃ©titifs sur de grandes quantitÃ© de donnÃ©es Donc pour mon code, Julia a montrÃ© de meilleures performances en machine Learning.</p>
<p>Jâ€™ai essayÃ© de faire quelques visualisations sur R et Julia. Lâ€™idÃ©e Ã©tait de faire de graphique comme des histogrammes et dâ€™autres visualisation que nous allons insÃ©rer par la suite dans notre application shiny.</p>
<p>Voici quelques exemples de visualisations faites:</p>
<p>```{julia, echo=False} using ProjetRJulia using DataFrames using Plots using StatsPlots</p>
<p>gr()</p>
<p>#Charger le dataset data = ProjetRJulia.load_data()</p>
<p>histogram(data.radius_mean,title=â€œHistogramme radius_meanâ€, xlabel=â€œradius_meanâ€, ylabel=â€œFrÃ©quenceâ€, legend=false)</p>
<p>histogram(data.area_mean,title=â€œHistogramme area_meanâ€, xlabel=â€œarea_meanâ€, ylabel=â€œFrÃ©quenceâ€, legend=false)</p>
<p>histogram(data.symmetry_mean,title=â€œHistogramme symmetry_meanâ€, xlabel=â€œsymmetry_meanâ€, ylabel=â€œFrÃ©quenceâ€, legend=false)</p>
<p>violin(data.texture_mean, title=â€œViolinplot de texture_meanâ€, ylabel=â€œtexture_meanâ€, xlabel=â€œCategoryâ€, legend=false)</p>
<p>boxplot(data.diagnosis, data.area_se, title=â€œBoxplot of area_se by Diagnosisâ€, xlabel=[â€œBÃ©ninâ€,â€œMalinâ€], ylabel=â€œarea_seâ€)</p>
<p>```</p>
<p>Jâ€™ai aussi essayÃ© de me servir de Rulia pour quand mÃªme essayer un petit peu mais jâ€™ai beaucoup de mal Ã  comprendre et avec tout les autres problÃ¨mes qui sont apparus je nâ€™ai pas bien eu le temps de mâ€™y intÃ©resser plus.</p>
<p>Un des derniÃ¨res Ã©tapes de notre projet a Ã©tÃ© de crÃ©er les packages qui regroupe toutes nos fonctions crÃ©Ã©es pour les rendre facilement rÃ©utilisables. Nous avons crÃ©Ã© un package R et un autre Julia. Ce qui a Ã©tÃ© trÃ¨s compliquÃ© au dÃ©but surtout pour le package Julia.</p>
<p>Pour Julia jâ€™ai commencÃ© par suivre un tutoriel trouvÃ© en ligne, qui expliquait comment crÃ©er un package manuellement. Ce tuto montrait comment structurer correctement le package en dÃ©finissant un module portant le nom que lâ€™on voulait pour le package. Il indiquait Ã©galement la hiÃ©rarchie nÃ©cessaire avec des dossiers comme src/, les fichier Project.tomlâ€¦ Jâ€™ai donc compris la structure gÃ©nÃ©rale, mais la configuration Ã©tait trop compliquÃ©e. Heureusement nous avons eu un magnifique tuto crÃ©er par Mr Remy qui nous a expliquÃ© en dÃ©tails comment crÃ©er un package Julia de maniÃ¨re standard, ce qui mâ€™a permis de corriger ce que jâ€™avais fats prÃ©cÃ©demment, maintenant on est des expertes dans la crÃ©ation de package.</p>
<p>Un des problÃ¨mes que jâ€™ai rencontrÃ© dans la crÃ©ation de mon package, concernÃ© le dÃ©pÃ´t sur GitHub. Lors de la crÃ©ation de mon repository, je cochais systÃ©matiquement la case Â« Add a README file Â» qui provoquait des conflits avec les fichiers que jâ€™essayais de push. Jâ€™ai donc du recrÃ©er plusieurs fois un package avant de comprendre dâ€™oÃ¹ venait lâ€™erreur. Une autre erreur qui apparait, tous mes push depuis la crÃ©ation du package ont des erreurs mais toutes les mises a jour que je fais sont bien dans le GitHub alors je ne comprends pas. Finalement jâ€™ai rÃ©ussi Ã  tout configurer correctement et jâ€™ai nommÃ© mon package ProjetRJulia.jl qui est dÃ©sormais fonctionnel et accessible.</p>
<p>Le plus grand dÃ©fi que jâ€™ai rencontrÃ© lors de la crÃ©ation de mon package a Ã©tÃ© la mise en place et le processus de push sur GitHub. A chaque tentative de push, sans exception (je ne mens pas) jâ€™ai rencontrÃ© des Ã©checs. Il y avait toujours un problÃ¨me, ce qui mâ€™a demandÃ© Ã©normÃ©ment de temps pour tout rÃ©soudre.</p>
<p>Au dÃ©but le problÃ¨me principal venait des packages utilisÃ©s dans mon code. Ils nâ€™Ã©taient pas correctement intÃ©grÃ©s dans mon package ProjetRJulia.jl. Ce qui gÃ©nÃ©rait des erreurs lors de lâ€™exÃ©cution. Pour rÃ©soudre Ã§a, jâ€™ai dÃ» mâ€™assurer que tous les packages nÃ©cessaires Ã©taient bien chargÃ©s dans le fichier Project.toml avant de pouvoir pousser les premiers commits.</p>
<p>Ensuite jâ€™ai rencontrÃ© des problÃ¨mes de version. Mon package Ã©tait dÃ©fini avec la version 1.10 mais certains des autres packages, comme Pkg, Ã©taient sur la version 1.11, qui correspond Ã  la derniÃ¨re version de Julia. Ce qui a causÃ© des conflits de version lors du push. De mÃªme, les packages ScikitLearn cherchait Ã  installer des versions de packages plus anciennes que celles dÃ©jÃ  prÃ©sentes sur mon systÃ¨me, ce qui a provoquÃ© des erreurs, encore. Pour rÃ©soudre ce problÃ¨me jâ€™ai du supprimer tous les packages et rÃ©installer ScikitLearn en premier, puis ajouter les autres packages par la suite dans le bon ordre.</p>
<p>Le dernier problÃ¨me Ã©tait liÃ© Ã  la gestion de la base de donnÃ©es. Sur GitHub, le chemin pour accÃ©der a mon fichier de donnÃ©es nâ€™Ã©tait pas valide, car il faisait rÃ©fÃ©rence au chemin local de mon ordinateur. Pour contourner ce problÃ¨me, jâ€™ai crÃ©Ã© une fonction permettant de charger dynamiquement le dataset, de maniÃ¨re que le package puisse Ãªtre utilisÃ© par nâ€™importe qui, peu importe ou il est installÃ©. Cette fonction ne dÃ©pend dÃ©sormais que du rÃ©pertoire spÃ©cifiÃ© dans le package, ce qui rend lâ€™utilisation du package plus flexible et compatible sur diffÃ©rentes machines.</p>
<p>En rÃ©sume, la configuration correcte de lâ€™environnement, la gestion des versions des packages et lâ€™adaptation du code pour Ã©viter les dÃ©pendances spÃ©cifiques Ã  mon systÃ¨me local ont Ã©tÃ© des Ã©tapes clÃ©s pour rÃ©soudre ces problÃ¨mes et rÃ©ussir Ã  mettre en place et pousser sur GitHub.</p>
<p>Pour le package R, nous avions dÃ©veloppÃ© plusieurs scripts R, notamment pour lâ€™application Shiny et pour lâ€™algorithme de machine Learning et il fallait les placer dans un package. Jâ€™ai suivi un autre tutoriel en ligne qui expliquait Ã©tape par Ã©tape comment crÃ©er un package R en utilisant les outils de base. AprÃ¨s avoir vÃ©rifiÃ© que tout fonctionnait correctement, jâ€™ai Ã©galement dÃ©posÃ© ce package sur GitHub afin de le rendre accessible et rÃ©utilisable par dâ€™autres.</p>
<p>En conclusion cette Ã©tape de crÃ©ation de package a Ã©tÃ© une expÃ©rience enrichissante, mÃªme si ca a Ã©tÃ© compliquÃ©. Elle nous a permis de mieux comprendre les bonnes pratiques de structuration de projet en Julia et en R et lâ€™utilitÃ©s de lâ€™intÃ©gration avec GitHub.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>